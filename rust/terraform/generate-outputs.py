#!/usr/bin/env python3

import re

# Paths to the main.tf and outputs.tf files
MAIN_TF_PATH = "main.tf"
VALIDATOR_OUTPUTS_PATH = "modules/validator/outputs.tf"

# Output file
OUTPUTS_TF_PATH = "outputs.tf"

# Clear the outputs file
with open(OUTPUTS_TF_PATH, 'w') as file:
    file.truncate(0)

# Extract module names that use the validator source
with open(MAIN_TF_PATH, 'r') as file:
    main_tf_content = file.read()
MODULE_NAMES = re.findall(r'module "([^"]+)"[^{]*\{\s*source\s*=\s*"./modules/validator"', main_tf_content, re.DOTALL)

# Infer output names from the validator module's outputs.tf
with open(VALIDATOR_OUTPUTS_PATH, 'r') as file:
    validator_outputs_content = file.read()
OUTPUTS = re.findall(r'^output "([^"]+)', validator_outputs_content, re.MULTILINE)

# Loop through each module and create output definitions
with open(OUTPUTS_TF_PATH, 'a') as file:
    file.write(
'''# THIS FILE IS AUTOMATICALLY GENERATED BY RUNNING
# ./generate-outputs.py

''')
    for module_name in MODULE_NAMES:
        for output in OUTPUTS:
            # Create the output entry
            file.write(f'output "{module_name}_{output}" {{\n')
            file.write(f'  value = module.{module_name}.{output}\n')
            if "secret" in output:
                file.write(f'  sensitive = true\n')
            file.write('}\n\n')  # Add an empty line for readability

# Display the generated outputs
with open(OUTPUTS_TF_PATH, 'r') as file:
    print(file.read())
